#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
import pyrealsense2 as rs
import numpy as np
import cv2
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import signal
import sys

# Global flag for interrupt handling
isOk = True # Flag to indicate if the program should continue running

def signalInterruption(signum, frame): # Signal handler for interrupt signal (Ctrl-C)
    global isOk # Access the global flag variable
    print("\nCtrl-C pressed, stopping the program.") # Print a message indicating the program is stopping
    isOk = False # Set the flag to False to stop the program

signal.signal(signal.SIGINT, signalInterruption) # Register the signal handler for interrupt signal

# Class to handle RealSense camera input and publish ROS messages
class RealSenseCamera(Node): # Create a class that inherits from the Node class
    def __init__(self): # Constructor for the class
        super().__init__('realsense_camera') # Call the constructor of the parent class
        self.bridge = CvBridge() # Create a CvBridge object for converting ROS images to OpenCV images
        self.image_publisher = self.create_publisher(Image, 'realsense/image', 10) # Create a publisher for the color image topic
        self.depth_publisher = self.create_publisher(Image, 'realsense/depth', 10) # Create a publisher for the depth image topic

        # Initialize and start the RealSense camera
        self.pipeline = rs.pipeline() # Create a RealSense pipeline object
        config = rs.config() # Create a RealSense configuration object
        config.enable_stream(rs.stream.depth, 640, 480, rs.format.z16, 30) # Enable depth stream with specified parameters
        config.enable_stream(rs.stream.color, 640, 480, rs.format.bgr8, 30) # Enable color stream with specified parameters
        self.pipeline.start(config) # Start the RealSense pipeline

    def capture_and_publish(self): # Method to capture camera images and publish them as ROS messages
        frames = self.pipeline.wait_for_frames() # Wait for the next set of frames from the camera
        depth_frame = frames.get_depth_frame() # Get the depth frame from the frames
        color_frame = frames.get_color_frame() # Get the color frame from the frames

        if not depth_frame or not color_frame: # If either frame is missing, return
            return

        # Convert images to numpy arrays
        depth_image = np.asanyarray(depth_frame.get_data()) # Convert the depth frame to a numpy array
        color_image = np.asanyarray(color_frame.get_data()) # Convert the color frame to a numpy array

        # Publish color and depth images
        self.publish_image(color_image, self.image_publisher, "image") # Publish the color image
        self.publish_image(depth_image, self.depth_publisher, "depth") # Publish the depth image

    def publish_image(self, image, publisher, frame_id): # Method to publish an image as a ROS message
        msg = self.bridge.cv2_to_imgmsg(np.array(image, dtype=np.uint8), "bgr8") # Convert the image to a ROS message
        msg.header.stamp = self.get_clock().now().to_msg() # Set the timestamp of the message
        msg.header.frame_id = frame_id # Set the frame ID of the message
        publisher.publish(msg) # Publish the message

    def clean_up(self): # Method to clean up resources and stop the RealSense camera
        self.pipeline.stop() # Stop the RealSense pipeline

def main(args=None): # Main function for the node
    rclpy.init(args=args) # Initialize the ROS client library
    node = RealSenseCamera() # Create an instance of the RealSenseCamera class

    try: # Run the node and handle exceptions
        while rclpy.ok(): # While the ROS client library is running
            node.capture_and_publish() # Capture camera images and publish them
            rclpy.spin_once(node, timeout_sec=0.1) # Run the node for a short time
    finally: # Clean up resources when exiting
        node.clean_up() # Clean up the RealSense camera
        rclpy.shutdown() # Shutdown the ROS client library
        
# Script trigger
if __name__ == '__main__':
    main()


