#!/usr/bin/python3

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
import math
import sys

class SmartControl(Node):
    def __init__(self):
        super().__init__('basic_move')
        self._logger = self.get_logger()
        
        # Initialize publishers and subscribers with error handling
        try:
            self._pub_velocity = self.create_publisher(Twist, '/multi/cmd_nav', 10)
            self._logger.info("Velocity publisher successfully created.")
        except Exception as e:
            self._logger.error(f"Failed to create velocity publisher: {str(e)}")

        try:
            self.create_subscription(LaserScan, '/scan', self.scan_callback, 10)
            self._logger.info("Scan subscription successfully created.")
        except Exception as e:
            self._logger.error(f"Failed to create scan subscription: {str(e)}")

        # State variables for obstacles
        self.obstacle_left = False
        self.obstacle_right = False
        self._scan_received = False  # To handle the 'no scan' state

        # Initialize control callback with timer
        try:
            self.create_timer(0.1, self.control_callback)
            self._logger.info("Control timer successfully created.")
        except Exception as e:
            self._logger.error(f"Failed to create control timer: {str(e)}")

    def scan_callback(self, msg):
        self._scan_received = True  # Update flag when scan message is received
        # Process scan data to find obstacles within 1 meter
        self.obstacle_left = any(msg.ranges[i] < 1.0 for i in range(len(msg.ranges)//2, len(msg.ranges)) if msg.ranges[i] > 0)
        self.obstacle_right = any(msg.ranges[i] < 1.0 for i in range(0, len(msg.ranges)//2) if msg.ranges[i] > 0)

    def control_callback(self):
        if not self._scan_received:
            # If no scan messages are received, stop the robot and log the issue
            self.publish_velocity(0, 0)
            self._logger.warn("No scan messages received; robot has been stopped.")
            return
        
        # Reset scan received flag
        self._scan_received = False
        
        # Determine action based on obstacle detection
        if self.obstacle_left and self.obstacle_right:
            self.publish_velocity(0, -0.5)  # Turn left
        elif self.obstacle_left:
            self.publish_velocity(0, 0.5)  # Turn right
        elif self.obstacle_right:
            self.publish_velocity(0, -0.5)  # Turn left
        else:
            self.publish_velocity(0.5, 0)  # Go straight

    def publish_velocity(self, linear, angular):
        try:
            msg = Twist()
            msg.linear.x = linear
            msg.angular.z = angular
            self._pub_velocity.publish(msg)
            self._logger.info("Velocity command published.")
        except Exception as e:
            self._logger.error(f"Failed to publish velocity command: {str(e)}")

def main(args=None):
    rclpy.init(args=args)
    node = SmartControl()
    try:
        rclpy.spin(node)
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()



