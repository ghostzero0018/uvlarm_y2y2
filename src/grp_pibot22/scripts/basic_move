#!/usr/bin/python3
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist
from sensor_msgs.msg import PointCloud
from geometry_msgs.msg import Point32
import time
import math
import sys

class StraightCtrl(Node):
    def __init__(self):
        super().__init__('basic_move')
        self._logger = self.get_logger()
        self._pubVelocity = self.create_publisher(Twist, '/multi/cmd_nav', 10)
        self.create_subscription(PointCloud, '/points', self.scan_callback, 10)

        # Robot state variables
        self._obs_left = False
        self._obs_right = False
        self._is_reversing = False
        self._current_linear_velocity = 0.0
        self._current_angular_velocity = 0.0

        # Movement parameters
        self._velocity_smoothing_factor = 0.08
        self._max_linear_speed = 0.6
        self._max_angular_speed = 1.8

        # Initialize the control callback
        self.create_timer(0.05, self.control_callback)

    def scan_callback(self, pointCloud):
        self._obs_left = any(p.y > 0 for p in pointCloud.points)
        self._obs_right = any(p.y <= 0 for p in pointCloud.points)

    def control_callback(self):
        if not self._is_reversing:
            if self._obs_left and self._obs_right:
                # Decide direction based on obstacle density
                self._current_angular_velocity = -self._max_angular_speed if self._obs_left else self._max_angular_speed
            else:
                self._current_linear_velocity = self._max_linear_speed
                self._current_angular_velocity = 0.0

        # Publish the velocity command
        velocity_msg = Twist()
        velocity_msg.linear.x = self._current_linear_velocity
        velocity_msg.angular.z = self._current_angular_velocity
        self._pubVelocity.publish(velocity_msg)

def main():
    rclpy.init()
    node = StraightCtrl()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

# Script trigger
if __name__ == '__main__':
    main()

