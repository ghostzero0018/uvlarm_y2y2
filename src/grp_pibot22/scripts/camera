#!/usr/bin/python3

import pyrealsense2 as rs
import math
import signal
import numpy as np
import cv2
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from std_msgs.msg import String, Float32
from cv_bridge import CvBridge

class Realsense(Node):
    def __init__(self, fps=60):
        super().__init__('supermove_proto')
        self.image_publisher = self.create_publisher(Image, 'image', 10)
        self.detection_publisher = self.create_publisher(String, 'detection', 10)
        self.distancebottle_publisher = self.create_publisher(Float32, 'distancebottle', 10)
        self.x_publisher = self.create_publisher(Float32, 'x', 10)
        self.y_publisher = self.create_publisher(Float32, 'z', 10)
        self.bridge = CvBridge()
        self.pipeline = rs.pipeline()
        self.colorizer = rs.colorizer()
        config = rs.config()
        config.enable_stream(rs.stream.color, 848, 480, rs.format.bgr8, fps)
        config.enable_stream(rs.stream.depth, 848, 480, rs.format.z16, fps)
        self.align_to = rs.stream.color
        self.align = rs.align(self.align_to)
        self.pipeline.start(config)
        self.isOk = True
        self.color_info = (0, 0, 255)  # Red color for drawing circles

    def log(self, message, level='info'):
        if level == 'debug':
            self.get_logger().debug(message)
        elif level == 'warn':
            self.get_logger().warn(message)
        elif level == 'error':
            self.get_logger().error(message)
        else:
            self.get_logger().info(message)

    def read_imgs(self):
        frames = self.pipeline.wait_for_frames()
        aligned_frames = self.align.process(frames)
        depth_frame = aligned_frames.get_depth_frame()
        color_frame = aligned_frames.get_color_frame()

        if not depth_frame or not color_frame:
            self.log("Frames not available.", 'error')
            return

        self.color_image = np.asanyarray(color_frame.get_data())
        hsv = cv2.cvtColor(self.color_image, cv2.COLOR_BGR2HSV)
        mask = cv2.inRange(hsv, (50, 100, 50), (85, 255, 255))

        kernel = np.ones((5, 5), np.uint8)
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)
        mask = cv2.GaussianBlur(mask, (7, 7), 0)

        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        detected_objects = []

        for contour in contours:
            if cv2.contourArea(contour) < 100:
                continue
            ((x, y), radius) = cv2.minEnclosingCircle(contour)
            if radius < 10:
                continue

            # Check for overlapping circles
            is_overlapping = any(
                math.hypot(ox - x, oy - y) < (oradius + radius) * 0.8
                for ox, oy, oradius in detected_objects
            )
            if not is_overlapping:
                detected_objects.append((x, y, radius))
                depth = depth_frame.get_distance(int(x), int(y))
                cv2.circle(self.color_image, (int(x), int(y)), int(radius), self.color_info, 2)
                cv2.putText(
                    self.color_image, f"Dist: {depth:.2f}m",
                    (int(x) + 10, int(y) - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5,
                    self.color_info, 2
                )

        if detected_objects:
            self.publish_feedback([(x, y, depth_frame.get_distance(int(x), int(y))) for x, y, radius in detected_objects])
        else:
            self.log("No objects detected.")

        cv2.imshow('RealSense - Color', self.color_image)
        cv2.imshow('RealSense - Mask', mask)
        cv2.waitKey(1)

    def publish_feedback(self, detected_objects):
        for x, y, depth in detected_objects:
            self.detection_publisher.publish(String(data=f"Object detected at ({x}, {y}) with distance: {depth:.2f}m"))
            self.x_publisher.publish(Float32(data=float(x)))
            self.distancebottle_publisher.publish(Float32(data=depth))

    def signalInteruption(self, signum, frame):
        self.log("Ctrl-C pressed", 'warn')
        self.isOk = False

    def publish_imgs(self):
        msg_image = self.bridge.cv2_to_imgmsg(self.color_image, "bgr8")
        msg_image.header.stamp = self.get_clock().now().to_msg()
        self.image_publisher.publish(msg_image)

def process_img(args=None):
    rclpy.init(args=args)
    rsNode = Realsense()
    signal.signal(signal.SIGINT, rsNode.signalInteruption)
    while rsNode.isOk:
        rsNode.read_imgs()
        rsNode.publish_imgs()
        rclpy.spin_once(rsNode, timeout_sec=0.001)

    rsNode.pipeline.stop()
    rsNode.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    process_img()




