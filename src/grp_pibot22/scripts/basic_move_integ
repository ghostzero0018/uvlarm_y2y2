#!/usr/bin/python3

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import LaserScan, PointCloud
from geometry_msgs.msg import Twist, Point32
import math
import time

class RobotController(Node): # Create a RobotController class
    def __init__(self): # Constructor
        super().__init__('robot_controller') # Initialize the node
        self.publisher = self.create_publisher(Twist, '/multi/cmd_nav', 10) # Create a publisher for Twist messages
        self.subscription = self.create_subscription( # Create a subscription to LaserScan messages
            LaserScan, 'scan', self.scan_callback, 10 # Set the callback function
        )
        self.get_logger().info("Node initialized and ready.") # Log initialization message

        # Movement parameters
        self._obs_left = False # Initialize the left obstacle flag
        self._obs_right = False # Initialize the right obstacle flag
        self._current_linear_velocity = 0.0 # Initialize the current linear velocity
        self._current_angular_velocity = 0.0 # Initialize the current angular velocity
        self._velocity_smoothing_factor = 0.08 # Set the velocity smoothing factor
        self._max_linear_speed = 0.6 # Set the maximum linear speed
        self._max_angular_speed = 1.8 # Set the maximum angular speed

    def scan_callback(self, scanMsg): # Callback function for LaserScan messages
        distance_threshold = 0.6 # Meters
        angle_detection = 65  # Degrees

        angle_min = -angle_detection * (math.pi / 180) # Convert to radians
        angle_max = angle_detection * (math.pi / 180) # Convert to radians
        index_min = int((angle_min - scanMsg.angle_min) / scanMsg.angle_increment) # Calculate indices
        index_max = int((angle_max - scanMsg.angle_min) / scanMsg.angle_increment) # Calculate indices
 
        pointCloud = PointCloud() # Create a point cloud to store detected points
        pointCloud.header = scanMsg.header # Set the header
        self._obs_left = False # Reset the obstacle flags
        self._obs_right = False # Reset the obstacle flags

        for i in range(index_min, index_max + 1): # Iterate over the range of angles
            if 0.05 < scanMsg.ranges[i] < distance_threshold: # Check for obstacles
                angle = scanMsg.angle_min + i * scanMsg.angle_increment # Calculate the angle
                aDistance = scanMsg.ranges[i] # Get the distance
                if math.sin(angle) > 0: # Check if the obstacle is on the left
                    self._obs_left = True # Set the left obstacle flag
                else:
                    self._obs_right = True # Set the right obstacle flag

        self.control_movement() # Control the movement based on the obstacles

    def control_movement(self): # Control the movement based on the obstacles
        target_linear_velocity = 0.0 # Initialize the target linear velocity
        target_angular_velocity = 0.0 # Initialize the target angular velocity

        if self._obs_left and self._obs_right: # Check if obstacles are on both sides
            target_angular_velocity = -self._max_angular_speed if self._obs_left else self._max_angular_speed # Decide direction based on obstacle density
        else:
            target_linear_velocity = self._max_linear_speed # Move forward
            target_angular_velocity = 0.0 # Stop turning

        self._current_linear_velocity += self._velocity_smoothing_factor * (target_linear_velocity - self._current_linear_velocity) # Smooth the linear velocity
        self._current_angular_velocity += self._velocity_smoothing_factor * (target_angular_velocity - self._current_angular_velocity) # Smooth the angular velocity

        velocity_msg = Twist() # Create a Twist message
        velocity_msg.linear.x = self._current_linear_velocity # Set the linear velocity
        velocity_msg.angular.z = self._current_angular_velocity # Set the angular velocity
        self.publisher.publish(velocity_msg) # Publish the velocity command

def main(args=None): # Main function
    rclpy.init(args=args) # Initialize the ROS client library
    node = RobotController() # Create an instance of the RobotController class
    rclpy.spin(node) # Spin the node
    node.destroy_node() # Destroy the node
    rclpy.shutdown() # Shutdown the ROS client library

# Script trigger
if __name__ == '__main__':
    main()
